[{"title":"Javascript中的Undefined和null类型","date":"2017-10-26T15:23:19.132Z","path":"2017/10/26/title- Javascript中的Undefined和Null/","text":"前文在开始之前呢,我们需要搞清楚一个js的规则:打印一个未声明的变量时,会报错 12console.log(m) // &quot;ReferenceError: m is not defined&quot;console.log(obj.m) // &quot;ReferenceError: obj is not defined&quot; 打印一个已声明变量的一个未定义属性时,不会报错,值为undefined123console.log(window.m) // undefinedvar obj=&#123;&#125;console.log(obj.m) // undefined 打印一个已声明未初始化变量的属性时,会报错12var objconsole.log(obj.m) // &quot;TypeError: Cannot read property &apos;m&apos; of undefined&quot; UndefinedUndefined就是已声明变量但还未初始化的一个值.1234var a console.log(a) // undefined// 当然 var a 和 var a = undefined 是等价的.但是我们没有必要这么做,因为未经初始化的值默认就会取得undefined// undefined 主要用于比较 看这个例子123var message // 由于message声明而未初始化,值为undefinedconsole.log(typeof message) // 等价于 typeof undefined ==&gt; &apos;undefined&apos; console.log(typeof age) // undefined (注意,这个age是没有被声明的) 大家可能很好奇, 前文不是说了,打印未定义的变量会报错么?注意啦,这里是typeof age 而不是console.log(age)这就很蛋疼了,已声明和未声明 用typeof 都是 undefined.但是有人可能问了,那这该怎么办呢?有没有什么办法能够分清楚已声明变量和未声明变量呢?其实也是有办法的.我们对每个已声明变量都初始化.这样当typeof 操作符返回 “undefined” 时,我们就知道被检测的变量还没有被声明,而不是被初始化 总结一下什么情况下会 出现undefined: 已声明变量但还未初始化的变量 一个已声明变量的一个未定义属性 typeof 一个已声明未初始化的变量 typeof 一个未声明的变量Null高程上说 null是一个空对象指针,所以typeof null === ‘object’ 这条特殊的规则记住就好啦由于undefined是由null派生而来12console.log(undefined == null) // trueconsole.log(undefined === null) // false 反正以后也是一直在用===所以这两个值还是不一样的那么这个null该怎么用呢?前面我们说过,变量都要初始化,如果找不到合适的值那么就用null123var obj = &#123;&#125; // Avar obj = &#123;name: undefined&#125; // B (显示的初始化为undefined相当于没有初始化)if (obj.name === undefined)&#123;...&#125; // A,B都成立 1234var obj = &#123;name: null&#125; // Avar obj = &#123;name: undefined&#125; // Bvar obj = &#123;&#125; // Cif (obj.name === null)&#123;...&#125; // 只有A成立 总结我们在声明变量的时候最好初始化为null,这样就可以排除未声明,已声明未定义的变量(或者一个变量的属性).","tags":[]},{"title":"如何改变sumlime 3的图标","date":"2017-03-13T14:39:21.000Z","path":"2017/03/13/title- 如何改变sublime 3的图标/","text":"首先需要两个工具: ResEdit http://pan.baidu.com/share/link?uk=3030058&amp;shareid=429117308 Axialis IconWorkshop http://www.skycn.com/soft/appid/6671.html 开始我们打开ResEdit 点击File-Open project 选择你安装包里的那个sublime_txt.exe文件(不是你桌面的那个).在右侧我们可以看出这个ico文件包含了三个尺寸的ico,分别是1616,3232,48*48 我们去 http://www.easyicon.net/ 这个网站找图标,下载这三个尺寸的,后缀名是.ico打开Axialis IconWorkshop,点击来自数个图像的window图标 然后选择所有文件 .把刚才下载好的那三个尺寸的ico文件加进去.最后保存下就算合成为一个ico文件了.最后打开ResEdit 选择icon右键-Add Resource-icon-确定. 然后找到我们刚才合成的那个ico文件.删除原来 icon下sublime自带的那个icon.","tags":[]},{"title":"原生js对象的浅拷贝和深拷贝的总结","date":"2017-03-04T16:34:14.000Z","path":"2017/03/05/title- 原生js对象的浅拷贝和深拷贝的总结/","text":"这里是说明. 在此之前我们先复习两个知识点. 第一个知识点:对象方括号表示法 一般来说,访问对象属性时使用的都是点表示法,这也是很多面向对象语言中通用的语法.不过在Javascript也可以用方括号表示法来访问对象的属性.在使用方括号语法时,应该将要访问的属性以字符串的形式放在方括号中 123456var person = &#123; name : &quot;gay&quot;&#125;alert(person[&quot;name&quot;]); // &quot;gay&quot;alert(person.name); // &quot;gay 优点可以通过变量来访问属性,例如:123var propertyName = &quot;name&quot;;alert(person[propertyName]); // &quot;gay&quot; 如果属性名中包含会导致语法错误的字符,或者属性名使用的是关键字火保留字,也可以使用方括号表示法.例如:1person[&quot;first name&quot;] = &quot;gay&quot;; 由于”first name”中包含一个空格,所以不能使用点表示发来访问它.然而,属性名中是可以包含非字母非数字的,这时候就可以使用方括号表示法来访问它们. 通常,除非必须使用变量来访问属性,否则我们建议使用点表示法.第二个知识点:函数传递参数: ECMAScript中所有的函数都是按值传递!!!! —–高程第三版P70 ECMAScript中所有的函数都是按值传递!!!! —–高程第三版P70 ECMAScript中所有的函数都是按值传递!!!! —–高程第三版P70 函数内部声明的变量都是临时变量!在函数执行完之后也会被销毁!!! 函数内部声明的变量都是临时变量!在函数执行完之后也会被销毁!!! 函数内部声明的变量都是临时变量!在函数执行完之后也会被销毁!!! 在JS中,如果一个引用类型赋值给一个变量,那么这个变量装的是这个对象的地址!!! 在JS中,如果一个引用类型赋值给一个变量,那么这个变量装的是这个对象的地址!!! 在JS中,如果一个引用类型赋值给一个变量,那么这个变量装的是这个对象的地址!!!其实记住上面三句话,可以理解好多问题 几个例子解决你疑惑第一个例子:1234567function addTen(num)&#123; num += 10;&#125;var count = 20;addTen(count);console.log(count);//20console.log(num);//&quot;ReferenceError: num is not defined 分析一下函数 :这个函数里面声明了一个临时变量num,,然后这个临时变量会在函数结束后消失.所以当我们即使把count的值传给num,也不会影响count的值.而最后输出num的值也会出现未定义错误. 第二个例子12345678function addTen(num)&#123; num += 10; return num;&#125;var count = 20;var result = addTen(count);console.log(count);//20console.log(result);//30 分析:如果我们想要函数里面的那个临时变量num的值该怎么办呢? 那么我们就要把它return出来,最后可以看出 count输出20 ,result(也就是临时变量num的值,num变量在函数调用后已经消失,它的唯一作用就是临死前告诉result它的值是多少)是30. 第三个例子123456789var person = &#123; name : &quot;wsy&quot;&#125;function setName(obj)&#123; obj.name = &quot;gay&quot;&#125;setName(person);console.log(person.name);// &quot;gay&quot;console.log(obj.name);//&quot;ReferenceError: obj is not defined 分析:有人可能会说,你不是说是值传递么,为什么还会改变原来对象name的值.可是我还说了一句话 在JS中,如果一个引用类型赋值给一个变量,那么这个变量装的是这个对象的地址!!!setName(person);进入函数后,我们定义一个临时变量obj,这个obj里装的是person对象的地址.注意是地址.学过c语言的同学肯定好理解,这个obj说白了就是一个指针变量呗.所以,当我们obj.name = “gay”改变的就是原来那个对象的name,因为他们共享一个地址.所以console.log(person.name);// “gay”.又因为obj只是一个临时变量,所以在函数外输出obj.name肯定找不到了.因为obj已经挂了.第四个例子12345678function setName(obj)&#123; obj.name = &quot;gay&quot; obj = new Object(); obj.name = &quot;les&quot;&#125;var person = new Object();setName(person);console.log(person.name);//&quot;gay&quot; 分析:我们定义一个person对象.setName(person);然后进入函数,首先给临时变量obj给一个值(person的地址).然后obj.name = “gay”,因为obj和person共享一个地址,所以person的name属性也变成了”gay”.然后 obj = new Object(); .注意这里 重新new了一个对象,(也就是重新在堆内存里分配了一块地址)给临时变量obj.此时,obj里装的地址和person的地址并不是一个值.也就是说改变obj.name并不会影响到person. 最后一个例子12345678910function setName(obj)&#123; obj.name = &quot;gay&quot; obj = new Object(); obj.name = &quot;les&quot; return obj;&#125;var person = new Object();var person1 = setName(person);console.log(person.name);//&quot;gay&quot;console.log(person1.name);//&quot;les&quot; 这个例子无非就是想把这个新开辟的obj返回出来.so easy~ 总结其实我们发现,红皮书说的真好,js函数传递就是值传递.可为什么传递引用类型时会改变原来的值呢?是因为传引用对象时,其实传递的是他的地址.所以他们共享地址了.这就是传说中的 call by shareing!OK,让我们进入正题! 浅拷贝:简单讲，浅拷贝就是复制一份引用，所有引用对象都指向一份数据，并且都可以修改这份数据 123456var person = &#123; name : &quot;wsy&quot;&#125;var person1 = person;person1.name = &quot;yxy&quot;;console.log(person.name); // yxy 从上述代码中我们可以发现,改变person1的name值然后person的值也跟着改变.内存分析图: 再看一段代码: 1234567891011121314var Chinese = &#123; name : &quot;China&quot;&#125;function extendCopy(p) &#123; var c = &#123;&#125;; for (var i in p) &#123; c[i] = p[i]; &#125; return c;&#125;var Doctor = extendCopy(Chinese);alert(Doctor.name);//ChinaDoctor.name = &quot;USA&quot;alert(Chinese.name);//China 解释下这个函数,创建一个c对象,然后 c[“name”] = p[“name”];但是 改变c的name属性并不影响p的属性.再往下看 12345Chinese.birthPlaces = [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;];var Doctor = extendCopy(Chinese);Doctor.birthPlaces.push(&apos;厦门&apos;);alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门 假如我们给Chinese添加一个属性,这个属性为一个数组对象.然后再进行extendCopy函数赋值给Doctor.我们会发现改变Doctor的值会影响Chinese的值.也就是说Doctor.birthPlaces 和 ChinesePlaces指向了同一块内存.经实验,我们发现在extendCopy(p)函数中:如果参数p的某一个属性为基本类型.则为值传递(也就是仅仅简简单单的赋值)如果参数p的某一个属性为引用类型(对象),则为引用传递(这俩个对象的这个属性指向同一块内存)所以，extendCopy() 只是拷贝了基本类型的数据，我们把这种拷贝叫做“浅拷贝”。知乎用户MickeyHong:Javascript 对于复制的问题其实有些模糊 不过总的来说 你只要记住Object在Javascript里是pass by reference的 其余的都是pass一个复制值 (我知道有人会吵&gt;javascript都是pass by value的 而obj的value就是reference什么什么的) 深拷贝 所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难.深拷贝则是复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制 所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难.深拷贝则是复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制 所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难.深拷贝则是复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制直接撸代码:12345678910111213141516171819202122var Chinese = &#123; birthPlaces : [&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;]&#125;function deepCopy(p,c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === &apos;object&apos;) &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; //alert(i); // i = birthPlace //alert( c[i]);//空对象 //alert(p[i]);//[&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;]; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125;var Doctor = deepCopy(Chinese);Doctor.birthPlaces.push(&apos;厦门&apos;);alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门alert(Chinese.birthPlaces); //北京, 上海, 香港 这里我们实现了就算这个对象的某一个属性为Object类型的,我们可以让这两个对象的这个属性指向不同的内存. 所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难.深拷贝则是复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制 ok,分析一下函数:123456789101112131415function deepCopy(p,c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === &apos;object&apos;) &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; //alert(i); // i = &quot;birthPlace&quot; //alert( c[i]);//空对象 //alert(p[i]);//[&apos;北京&apos;,&apos;上海&apos;,&apos;香港&apos;]; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; 分析一下运行过程:var Chinese = { birthPlaces : [‘北京’,’上海’,’香港’]}现在Chinese只有一个属性,这个属性的值是一个数组(Array)一步一步分析: var Doctor = deepCopy(Chinese);给deepCopy传进入一个参数Chineese. var c = c || {};定义一个变量 c, 这个c的值是怎么计算的呢? 其实这里用了||的特性,如果传进来的c不为null那么新定义的c的值就是传进来的c的值,否则新定义的c等于一个空对象({ }).而我们第一次调用deepCopy时,只传进来一个一个参数,所以. 这里 var c = {}; 也就是定义c是一个空对象.\\ for (var i in p)这里由于p是一个对象,所以这里面的i值是循环p的属性.由于Chinese只有birthPlaces一个属性,所以只循环一次,i的值就是 “birthPlaces”(string类型). if (typeof p[i] === ‘object’)判断p[i]是不是Object类型的.这里面p[i]就是p[“birthPlaces”] 那么肯定是Object啊(这里用到的前面复习的第一个知识点::对象方括号表示法) c[i] = (p[i].constructor === Array) ? [] : {};判断p[i]到底是哪个Object类型的,如果是数组那么;c[“birthPlaces”]为空数组,如果是对象那么:c[“birthPlaces”]为空对象. deepCopy(p[i], c[i]);也就是deepCopy(p[“birthPlaces”],c[“birthPlaces”])也就是deepCopy([‘北京’,’上海’,’香港’],[]) ok,我们再进入一遍这个函数注意,刚才我们传进去俩个参数,p = [‘北京’,’上海’,’香港’],c = []; var c = c || {};然后 c = []; for (var i in p)这里p一个数组,所以i是这个数组的三个索引为 “0”, “1” “2”所以进行三次循环 (注意这个索引是string类型的 ) if (typeof p[i] === ‘object’)当i = “0”时,p[“0”] = “北京”, 而北京是一个string类型的.依次类推,这三次循环永远不会进入这个if语句里. 1234else &#123; c[i] = p[i]; &#125; 循环三次后,因为c本来就是一个数组.所以最后 c = [‘北京’,’上海’,’香港’]因为这个c和c[“birthPlaces”]共享地址,所以c[“birthPlaces”] = [‘北京’,’上海’,’香港’]; return c;在函数外var Doctor = deepCopy(Chinese);来接受这个我们在函数内新var的临时变量.总结: 深拷贝则是复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制 深拷贝则是复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制 深拷贝则是复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制","tags":[]},{"title":"javascript原型动态性","date":"2017-03-01T00:15:26.000Z","path":"2017/03/01/title- javascript原型动态性/","text":"实例1先上代码12345var friend= new Person();Person.prototype.sayHi = function()&#123; alert(&quot;hi&quot;);&#125;;friend.sayHi(); // &quot;hi&quot;(没有一点问题) 可以看到,就算我们先创建了实例,后改变了原型里的方法,最后也可以访问到sayHi方法.原因:原型链并没有被破坏,当我们调用friend.sayHi()是会在实例中搜索名为sayHi的属性,在没有找到的情况下,会继续搜索原型.因为实例与原型之间的连接只不过是一个指针,而非一个副本,因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数 实例2123456789101112131415function Person()&#123;&#125;var friend = new Person();Person.prototype = &#123; constructor: Person, name: &quot;Nicholas&quot;, age: 29, job: &quot;Software&quot;, sayName: function()&#123; alert(this.name); &#125;&#125;;friend.sayName();// &quot;TypeError: friend.sayName is not a function 重写原型对象之间重写原型对象之后从图中可以看出原型链已经破坏,friend实例还是指向的原来的原型对象. 实例3那我们如果想让让friend访问到sayName()这个方法怎么办,于是我修改了下代码12345678910111213141516function Person()&#123;&#125;var friend = new Person();friend.__proto__ = &#123; constructor: Person, name: &quot;Nicholas&quot;, age: 29, job: &quot;Software&quot;, sayName: function()&#123; console.log(this.name); &#125;&#125;;friend.sayName();//&quot;Nicholas&quot;console.log(Person.prototype == friend.__proto__); // false 实例4优化一下1234567891011121314function Person()&#123;&#125;var friend = new Person();Object.assign(Object.getPrototypeOf(friend),&#123; name: &quot;Nicholas&quot;, age: 29, job: &quot;Software&quot;, sayName: function()&#123; console.log(this.name); &#125;&#125;);friend.sayName(); // &quot;Nicholas&quot;console.log(Person.prototype == friend.__proto__) // &quot;true&quot;","tags":[]},{"title":"百度前端学院","date":"2017-02-25T08:24:32.000Z","path":"2017/02/25/title- 百度前端学院/","text":"有趣的模糊实验数据绑定1数据绑定2新世界flexfish队列树形组件飞行游戏leetcode尧山多选组件111","tags":[]}]